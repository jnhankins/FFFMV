/**
 * FastFlameFractalMusicVideo (FFF)
 * An application for creating music videos using flame fractals.
 * Copyright (C) 2015  Jeremiah N. Hankins
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package fff.mv.core;

import fff.mv.util.PropertyChangeAdapter;
import fff.flame.Flame;
import java.io.Serializable;
import java.util.ArrayList;

/**
 * {@code KeyFlameList} represents the key-flame list of a {@code Project}.
 * <p>
 * The term "key flame" is meant to resemble the term "key frame" as it is used
 * in animation and film making.
 * <blockquote>
 * A key frame in animation and filmmaking is a drawing that defines the
 * starting and ending points of any smooth transition. The drawings are called
 * "frames" because their position in time is measured in frames on a strip of
 * film. A sequence of key frames defines which movement the viewer will see,
 * whereas the position of the key frames on the film, video or animation
 * defines the timing of the movement. Because only two or three key frames over
 * the span of a second do not create the illusion of movement, the remaining
 * frames are filled with inbetweens.
 * (<cite><a href="https://en.wikipedia.org/wiki/Key_frame">https://en.wikipedia.org/wiki/Key_frame</a></cite>)
 * </blockquote>
 * A {@code KeyFlameList} composed of sequence of {@link Entry} objects. Each
 * {@code Entry} object represents one "key flame" and is a simple paring of
 * a {@link ProjectFlame} with a time (specified in seconds).
 * <p>
 * Using the {@link #getFlame(double, fff.flame.Flame) getFlame()} method it is
 * possible to create smooth animations that rely on the key flame entries in
 * a {@code KeyFlameList}. The method takes a time value as a parameter and
 * returns a {@link Flame} object. If the time perfectly coincides with the time
 * of one of the key flames, then a copy of the flame contained in the key flame
 * will be returned. But more typically the parameterized time comes before, 
 * between, or after the times of the key flames. If the time comes before or
 * after the times, then the flame returned will be a copy of the first or last
 * key-flame's flame respectively. If the time is between the time of two 
 * consecutive key-flames, {@code A} and {@code B}, then the {@code Flame} that
 * will returned will be a new flame generated by
 * {@link Flame#lerp(fff.flame.Flame, fff.flame.Flame, float, fff.flame.Flame) interpolating}
 * between {@code A} and {@code B}.
 *
 * @author Jeremiah N. Hankins
 */
public class KeyFlameList extends PropertyChangeAdapter implements Serializable {
    /**
     * Indicates that an new {@link Entry} was {@link #add(fff.mv.core.ProjectFlame, double) added}.
     */
    public static final String ENTRY_ADDED_PROPERTY = "entryAdded";
    
    /**
     * Indicates that an {@link Entry} was {@link #remove(fff.mv.core.KeyFlameList.Entry) removed}.
     */
    public static final String ENTRY_REMOVED_PROPERTY = "entryRemoved";
    
    /**
     * The {@link Project} containing this {@code KeyFlameList}.
     */
    private final Project project;
    
    /**
     * The list of key flame {@link Entry} objects.
     */
    private final ArrayList<Entry> entries = new ArrayList();
    
    /**
     * An index used to improve the performance of 
     * {@link #getFlame(double, fff.flame.Flame) getFlame()} when the method's
     * {@code currTime} argument increases monotonically on successive 
     * invocations of the method.
     */
    private int index = -1;
    
    /**
     * Constructs a new empty {@code KeyFlameList} object with the specified 
     * {@link Project}.
     * 
     * @param project the {@code Project} containing the {@code KeyFlameList}
     */
    protected KeyFlameList(Project project) {
        this.project = project;
    }
    
    /**
     * Returns the {@link Project} containing the {@code KeyFlameList}.
     * 
     * @return the {@code Project} containing the {@code KeyFlameList}
     */
    public Project getProject() {
        return project;
    }
    
    /**
     * Returns the number of {@link Entry} objects in the {@code KeyFlameList}.
     *
     * @return the number of {@code Entry} objects in the {@code KeyFlameList}
     */
    public int size() {
        return entries.size();
    }
    
    /**
     * Returns the {@link Entry} at the specified index or {@code null} if 
     * there is no {@code Entry} at the specified index.
     * 
     * @param index the index of the {@code Entry} to return
     * @return the {@code Entry} at the specified index or {@code null}
     */
    public Entry get(int index) {
        if (index < 0 || size() <= index)
            return null;
        return entries.get(index);
    }
    
    /**
     * Removes the {@link Entry} at the specified index and returns the 
     * {@code Entry} that was removed. If there is no  {@code Entry} at the 
     *  specified index then this {@code KeyFlameList} is unmodified and 
     * {@code null} is returned.
     * <p>
     * If the {@code Entry} was removed successfully, then the project's 
     * {@code isSaved} flag will be set to {@code false} and an 
     * {@link #ENTRY_REMOVED_PROPERTY} event will be fired.
     * 
     * @param index the index of the {@code Entry} to be removed
     * @return the {@code Entry} that was removed or {@code null}
     */
    public Entry remove(int index) {
        if (index < 0 || size() <= index)
            return null;
        Entry entry = entries.remove(index);
        if (this.index > entries.size()-1)
            this.index = -1;
        project.setIsSaved(false);
        firePropertyChange(ENTRY_REMOVED_PROPERTY, entry, null);
        return entry;
    }
    
    /**
     * Removes the specified {@link Entry} from this {@code KeyFlameList}. 
     * Returns {@code true} if this {@code KeyFlameList} contained the specified 
     * {@code Entry} and was removed. If this {@code KeyFlameList} did not 
     * contain the specified {@code FlameInst} then this {@code KeyFlameList} is
     * unmodified.
     * <p>
     * If the {@code Entry} was successfully removed, then the project's 
     * {@code isSaved} flag will be set to {@code false} and an 
     * {@link #ENTRY_REMOVED_PROPERTY} event will be fired.
     * 
     * @param entry the {@code Entry} to be removed from this {@code KeyFlameList}
     * @return {@code true} if this {@code KeyFlameList} contained the specified {@code Entry}
     */
    public boolean remove(Entry entry) {
        if (entries.remove(entry)) {
            if (index > entries.size()-1)
                index = -1;
            project.setIsSaved(false);
            firePropertyChange(ENTRY_REMOVED_PROPERTY, entry, null);
            return true;
        }
        return false;
    }
    
    /**
     * Removes all {@link Entry} objects in this {@code KeyFlameList} containing
     * the specified {@link ProjectFlame}. Returns {@code true} if this
     * {@code KeyFlameList} contained at least {@code Entry} containing the
     * specified {@code ProjectFlame} and was removed.
     * <p>
     * If any entries are removed, the project's {@code isSaved} flag will be
     * set to {@code false}, and for each {@code Entry} removed successfully, an
     * {@link #ENTRY_REMOVED_PROPERTY} event will be fired.
     * 
     * @param pflame the {@code ProjectFlame} to search for and remove
     * @return {@code true} if this {@code KeyFlameList} contained at least
     * {@code Entry} containing the specified {@code ProjectFlame} and was
     * removed
     */
    public boolean remove(ProjectFlame pflame) {
        boolean isModified = false;
        for (int i=entries.size()-1; i>=0; i--) {
            KeyFlameList.Entry entry = entries.get(i);
            if (entry.getProjectFlame() == pflame) {
                remove(entry);
                isModified = true;
            }
        }
        return isModified;
    }
    
    /**
     * Removes all of the {@link Entry} objects from this {@code KeyFlameList}.
     * Returns {@code true} if at least one {@code Entry} was removed.
     * <p>
     * The {@code Entry} objects are removed by repeatedly removing the
     * {@code Entry} at index {@code 0} until there are no more {@code Entry}
     * objects in this {@code KeyFlameList}.
     * <p>
     * See {@link #remove(int)} for more information.
     * 
     * @return {@code true} if at least one {@code Entry} was removed.
     */
    public boolean clear() {
        if (entries.isEmpty())
            return false;
        while (!entries.isEmpty())
            remove(0);
        return true;
    }
    
    /**
     * Returns the index of the specified {@link Entry} in this 
     * {@code KeyFlameList}, or {@code -1} if the {@code KeyFlameList} does not
     * contain the {@code Entry}.
     * 
     * @param entry the {@code Entry} to be search for
     * @return the index of the specified {@code Entry}, or {@code -1}
     */
    public int indexOf(Entry entry) {
        return entries.indexOf(entry);
    }
    
    /**
     * Constructs a new {@link Entry} object with the specified
     * {@link ProjectFlame} at the specified time in seconds. Inserts the
     * {@link Entry} at an index such that all {@code Entry} objects in the
     * {@code KeyFlameList} with greater index also have greater times. Returns
     * the inserted {@code Entry}.
     * <p>
     * If the {@code Entry} is successfully added, the project's {@code isSaved}
     * flag will be set to {@code false} and a {@link #ENTRY_ADDED_PROPERTY}
     * event will be fired.
     * 
     * @param pflame the {@code ProjectFlame}
     * @param time the time in seconds
     * @return the {@code Entry}
     * @throws IllegalArgumentException if {@code pflame}'s project does not match this object's project
     * @throws IllegalArgumentException if {@code time} is not in range (-inf,inf)
     */
    public Entry add(ProjectFlame pflame, double time) {
        if (pflame.getProject() != project)
            throw new IllegalArgumentException("the pflame's project does not match this key flame list's project");
        if (!(Double.NEGATIVE_INFINITY<time && time<Double.POSITIVE_INFINITY))
            throw new IllegalArgumentException("time is not in range (-inf,inf): "+time);
        Entry entry = new Entry(pflame, time);
        int endtryIndex = 0;
        while (endtryIndex < entries.size()) {
            Entry e = entries.get(endtryIndex);
            if (time < e.getTime())
                break;
            endtryIndex++;
        }
        entries.add(endtryIndex, entry);
        project.setIsSaved(false);
        firePropertyChange(ENTRY_ADDED_PROPERTY, null, entry);
        return entry;
    }
    
    /**
     * Returns the {@link Flame} at the given time in seconds by extrapolating
     * between {@code Flame} objects contained in {@link Entry} objects in this
     * {@code KeyFlameList} using linear interpolation. If the {@code flame}
     * parameter is not {@code null}, the the results will be stored in the
     * parameterized {@code Flame}. If this {@code KeyFlameList} is empty,
     * then {@code null} will be returned.
     * <p>
     * Note: This method has been optimized to provide subtle performance
     * improvements when the {@code currTime} parameter monotonically increases
     * between successive calls to this method.
     * 
     * @param currTime the time in seconds
     * @param flame an optional {@code Flame} object in which results will be stored
     * @return the extrapolated {@code Flame} for the specified time
     */
    public Flame getFlame(double currTime, Flame flame) {
        // Get the number of key flames
        int size = entries.size();
        
        // If there are no flames in the interp list, then return null
        if (size < 1)
            return null;
        
        // If the current time comes before the time of the entry time
        // pointed to by the index, then reset the index to -1
        if (index >= 0 && currTime < entries.get(index).time)
            index = -1;
        
        // If the index currently indicates that the time comes before the
        // time of the first entry in the interp list...
        if (index < 0) {
            // If the time is infact before the time of the first entry in the
            // interp list... then copy the first entry's flame and return the
            // results
            if (currTime < entries.get(0).time) {
                if (flame == null) {
                    return new Flame(entries.get(0).pflame.getFlame());
                } else {
                    flame.set(entries.get(0).pflame.getFlame());
                    return flame;
                }
            }
            // The time is not actually before the time of the first entry in 
            // the interp list, so increment the index...
            index++;
        }
        
        // While the index currently indicates that the time is between the time
        // of the first and last entries in the interp list...
        while (index < size-1) {
            // If the time is infact before the time of the next entry in the
            // interp list... then we're at the corret index. 
            // Interpolate between the two flames and return
            if (currTime < entries.get(index+1).time) {
                // Get the entries
                Entry entry0 = entries.get(index);
                Entry entry1 = entries.get(index+1);
                // Calcualte the interpolation coefficient from the times
                double time0 = entry0.time;
                double time1 = entry1.time;
                float mix = time0==time1? 0.0f : (float)((currTime-time0)/(time1-time0));
                // Interpolate the flames and return the results
                return Flame.lerp(entry0.pflame.getFlame(), entry1.pflame.getFlame(), mix, flame);
            }
            // The time is after the next entry, so advane to the next index
            index++;
        }
        
        // Assert: The index indicates that the time must be after (or equal to) 
        // the time of the last entry in the interp list
        
        // Copy the last entry's flame and return the results
        if (flame == null) {
            return new Flame(entries.get(size-1).pflame.getFlame());
        } else {
            flame.set(entries.get(size-1).pflame.getFlame());
            return flame;
        }
    }
    
    /**
     * {@code Entry} combines an {@code ProjectFlame} with a 
     * {@link #getTime() time}.
     */
    public class Entry extends PropertyChangeAdapter implements Serializable {
        /**
         * Indicates that the {@link #getProjectFlame() flame} has changed.
         */
        public static final String ENTRY_FLAME_CHANGED_PROPERTY = "flame";
        
        /**
         * Indicates that the {@link #getTime() time} has changed.
         */
        public static final String ENTRY_TIME_CHANGED_PROPERTY = "time";
        
        /**
         * The {@link ProjectFlame} used by this key flame entry.
         */
        private ProjectFlame pflame; // Project flame
        
        /**
         * The time for this key flame entry
         */
        private double time;         // Seconds
        
        protected Entry(ProjectFlame pflame, double time) {
            this.pflame = pflame;
            this.time = time;
        }
        
        /**
         * Return the {@code KeyFlameList} containing this {@code Entry}, or
         * {@code null} if this {@code Entry} has been removed.
         * 
         * @return the {@code KeyFlameList} containing this {@code Entry}
         */
        public KeyFlameList getKeyFlameList() {
            if (!entries.contains(this))
                return null;
            return KeyFlameList.this;
        }

        /**
         * Returns this {@code Entry}'s {@link ProjectFlame}.
         * 
         * @return this {@code Entry}'s {@link ProjectFlame}.
         */
        public ProjectFlame getProjectFlame() {
            return pflame;
        }

        /**
         * Returns this {@code Entry}'s time in seconds.
         * 
         * @return this {@code Entry}'s time in seconds.
         */
        public double getTime() {
            return time;
        }
        
        /**
         * Sets the {@code ProjectFlame}.
         * <p>
         * If the {@code time} is changed successfully, the project's
         * {@code isSaved} flag will be set to {@code false} and a
         * {@link #ENTRY_FLAME_CHANGED_PROPERTY} event will be fired.
         * 
         * @param pflame the {@code ProjectFlame}
         * @throws IllegalArgumentException if {@code flame} is null
         */
        public void setProjectFlame(ProjectFlame pflame) {
            if (pflame == null)
                throw new IllegalArgumentException("flame is null");
            if (pflame.getProject() != project)
                throw new IllegalArgumentException("the pflame's project does not match this key flame list's project");
            ProjectFlame oldFlame = this.pflame;
            ProjectFlame newFlame = pflame;
            if (oldFlame != newFlame) {
                this.pflame = pflame;
                project.setIsSaved(false);
                firePropertyChange(ENTRY_FLAME_CHANGED_PROPERTY, oldFlame, newFlame);
            }
        }
        
        /**
         * Sets the time in seconds. 
         * <p>
         * If the {@code time} is changed successfully, the project's
         * {@code isSaved} flag will be set to {@code false} and a
         * {@link #ENTRY_TIME_CHANGED_PROPERTY} event will be fired.
         *
         * @param time the time in seconds
         * @throws IllegalArgumentException if {@code time} is not in range (-inf,inf)
         */
        public void setTime(double time) {
            if (!(Double.NEGATIVE_INFINITY<time && time<Double.POSITIVE_INFINITY))
                throw new IllegalArgumentException("time is not in range (-inf,inf): "+time);
            double oldTime = this.time;
            double newTime = time;
            if (oldTime != newTime) {
                this.time = time;
                entries.remove(this);
                int endtryIndex = 0;
                while (endtryIndex < entries.size()) {
                    Entry e = entries.get(endtryIndex);
                    if (time < e.getTime())
                        break;
                    endtryIndex++;
                }
                entries.add(endtryIndex, this);
                project.setIsSaved(false);
                firePropertyChange(ENTRY_TIME_CHANGED_PROPERTY, oldTime, newTime);
            }
        }
    }   
}
