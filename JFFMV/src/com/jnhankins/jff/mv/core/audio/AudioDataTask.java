/**
 * JFFMV - An application for creating music videos using flame fractals.
 * Copyright (C) 2015 Jeremiah N. Hankins
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

package com.jnhankins.jff.mv.core.audio;

import com.jnhankins.jff.mv.core.io.XugglerAudioInputStream;
import java.io.File;
import java.lang.Thread.UncaughtExceptionHandler;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import javax.sound.sampled.AudioInputStream;
import org.jtransforms.fft.FloatFFT_1D;

/**
 * {@code AudioDataTask} contains a worker thread that generates
 * {@link AudioData}.
 * 
 * @author Jeremiah N. Hankins
 */
public class AudioDataTask {
    /**
     * A state indicating that the task has been initialize but has not started
     * yet.
     */
    private static final int READY     = 0;
    /**
     * A state indicating that the renderer is currently running.
     */
    private static final int RUNNING   = 1;
    /**
     * A state indicating that the renderer has been completed.
     */
    private static final int COMPLETED = 2;
    /**
     * A state indicating that the renderer has been canceled.
     */
    private static final int CANCELLED = 3;
    
    /**
     * Keeps track of the task's state.
     */
    private volatile int state = READY;
    
    /** 
     * Synchronizes methods which query or alter the task's state.
     */
    private final ReentrantLock stateLock = new ReentrantLock();
    
    /**
     * Condition indicating the transition to the terminated state.
     * This condition is used used by the awaitTermination methods.
     */
    private final Condition termination = stateLock.newCondition();
    
    /**
     * The audio data results generated by this task.
     */
    private final AudioData data;
    
    /**
     * The thread that will generate the results.
     */
    private Thread workerThread;
    
    /**
     * An optional exception handler for dealing with exceptions in the worker
     * thread.
     */
    private UncaughtExceptionHandler exceptionHandler;
    
    /** 
     * Synchronizes methods which query or alter the exception handler.
     */
    private final ReentrantLock exceptionHandlerLock = new ReentrantLock();
    
    /**
     * Constructs a new {@code AudioDataTask}.
     * 
     * @param audioFile the source file for the audio data
     * @param sampleRate the sample rate of the input audio stream
     * @param fftLength the number of samples per FFT
     * @param fftOverlap the amount that two adjacent FFTs overlap
     * @throws IllegalArgumentException if {@code audioFile} is {@code null}
     * @throws IllegalArgumentException if {@code sampleRate} is not in range 1,inf)
     * @throws IllegalArgumentException if {@code fftLength} is not a power of two greater than 1
     * @throws IllegalArgumentException if {@code fftOverlap} is not in range [0,1)
     */
    public AudioDataTask(File audioFile, int sampleRate, int fftLength, double fftOverlap) {
        data = new AudioData(audioFile, sampleRate, fftLength, fftOverlap);
    }
    
    /**
     * Returns the {@link AudioData} containing the output generated by this
     * task so far.
     * 
     * @return the {@code AudioData} containing the output generated by this task so far
     */
    public AudioData getData() {
        return data;
    }
    
    /**
     * Sets the exception handler used to handle uncaught exceptions that may
     * occur while reading, decoding, and processing the audio input.
     * 
     * @param exceptionHandler the exception handler
     */
    public void setExceptionHandler(UncaughtExceptionHandler exceptionHandler) {
        exceptionHandlerLock.lock();
        try {
            this.exceptionHandler = exceptionHandler;
        } finally {
            exceptionHandlerLock.unlock();
        }
    }
    
    /**
     * Returns the exception handler used to handle uncaught exceptions that
     * may occur while reading, decoding, and processing the audio input.
     * 
     * @return the exception handler
     */
    public UncaughtExceptionHandler getExceptionHandler() {
        exceptionHandlerLock.lock();
        try {
            return exceptionHandler;
        } finally {
            exceptionHandlerLock.unlock();
        }
    }
    
    /**
     * Returns {@code true} if the task has been cancelled.
     * 
     * @return {@code true} if the task has been cancelled
     */
    public boolean isCancelled() {
        stateLock.lock();
        try {
            return state == CANCELLED;
        } finally {
            stateLock.unlock();
        }
    }
    
    /**
     * Returns {@code true} if the task has been completed.
     * 
     * @return {@code true} if the task has been completed
     */
    public boolean isCompleted() {
        stateLock.lock();
        try {
            return state == COMPLETED;
        } finally {
            stateLock.unlock();
        }
    }

    /**
     * Returns {@code true} if the task has been completed or cancelled.
     * 
     * @return {@code true} if the task has been completed or cancelled 
     */
    public boolean isTerminated() {
        stateLock.lock();
        try {
            return state == COMPLETED || state == CANCELLED;
        } finally {
            stateLock.unlock();
        }
    }

    /**
     * Attempts to cancel the task. This attempt will fail if the task has
     * already been completed or cancelled. If the task is successfully
     * cancelled, then threads blocked by this task's awaitTermination methods
     * will become unblocked and resume.
     *
     * @return {@code false} if the task could not be cancelled
     */
    public boolean cancel() {
        stateLock.lock();
        try {
            if (isTerminated())
                return false;
            state = CANCELLED;
            return true;
        } finally {
            stateLock.unlock();
        }
    }

    /**
     * Blocks the thread invoking this method until either
     * {@link #isTerminated()} returns {@code true} or the invoking thread is
     * interrupted, whichever happens first.
     *
     * @throws InterruptedException if the invoking thread is interrupted while waiting
     */
    public void awaitTermination() throws InterruptedException {
        stateLock.lock();
        try {
            while (!isTerminated())
                termination.await();
        } finally {
            stateLock.unlock();
        }
    }

    /**
     * Blocks the thread invoking this method until either
     * {@link #isTerminated()} returns {@code true}, the timeout occurs, or the
     * invoking thread is interrupted, whichever happens first.
     * 
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return {@code true} if this task terminated and {@code false} if the timeout elapsed before termination
     * @throws InterruptedException if the invoking thread is interrupted while waiting
     */
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {        stateLock.lock();
        long nanos = unit.toNanos(timeout);
        stateLock.lock();
        try {
            while (!isTerminated()) {
                if (nanos <= 0)
                    return false;
                nanos = termination.awaitNanos(nanos);
            }
            return true;
        } finally {
            stateLock.unlock();
        }
    }
    
    /**
     * Starts the audio data task. If this method or {@link #cancel()} has
     * already been invoked, subsequent invocations of this method will have no
     * effect.
     */
    public void start() {
        stateLock.lock();
        try {
            if (state == READY) {
                state = RUNNING;
                workerThread = new Thread(new Worker(), "AudioDataTask Worker");
                workerThread.start();
            }
        } finally {
            stateLock.unlock();
        }
    }
    
    /**
     * The main worker thread of {@code AudioDataTask}.
     */
    class Worker implements Runnable {
        @Override
        public void run() {
            try {
                final File audioFile = data.getAudioFile();
                final int sampleRate = data.getSampleRate();
                final int fftLength = data.getFFTLength();
                final double fftOverlap = data.getFFTOverlap();
                final int fftBinCount = data.getFFTBinCount();
                // Open the file as an audio input stream
                AudioInputStream ais = XugglerAudioInputStream.open(audioFile, 1, sampleRate, XugglerAudioInputStream.Encoding.FLT);
                // Create a byte buffer to store bytes read from the audio input
                // stream
                byte[] byteBuffer = new byte[fftLength*4];
                // Create a float buffer to convert the bytes into floats
                FloatBuffer floatBuffer = ByteBuffer.wrap(byteBuffer).order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();
                // Create a buffer to hold fft input
                float[] fftBufferI = new float[fftLength];
                // Create a buffer to hold fft output
                float[] fftBufferO = new float[fftLength];
                // Create the fft
                FloatFFT_1D fft = new FloatFFT_1D(fftLength);
                // Create a Hann window function
                float[] window = new float[fftLength];
                for (int i=0; i < fftLength; i++)
                    window[i] = (float)(0.5 * (1.0 - Math.cos(2.0 * Math.PI * i / (fftLength - 1.0))));
                // Calcualte the stream positions for the first frame
                long currStreamPos = 0;
                long nextStreamPos = (long)(fftLength/2);
                // Calcutate the number of samples that need to be read for the
                // first frame
                int slideLen = (int)(nextStreamPos-currStreamPos);
                // eofPos keeps track of the position in the audio input stream
                // at which the EOF was encoutnered (-1 means position unknown)
                long eofPos = -1;
                // Continue processing audio untill completed or cancelled
                while (state == RUNNING) {
                    // Read the bytes needed for this frame
                    int bytesRead = ais.read(byteBuffer, 0, slideLen*4);
                    // If fewee bytes wer read from the xuggler audio input
                    // stream than were requested, its because the stream
                    // reached EOF
                    if (bytesRead < slideLen*4) {
                        // Clamp bytesRead to be atleast 0 for convience
                        if (bytesRead < 0)
                            bytesRead = 0;
                        // If we havn't recorded the EOF position yet, do so now
                        if (eofPos < 0)
                            eofPos = currStreamPos + bytesRead;
                        // Zero out the rest of the bytes in the buffer
                        while (bytesRead < slideLen*4)
                            byteBuffer[bytesRead++] = 0;
                    }
                    // Convert the bytes into floats and store them at the end 
                    // of the input buffer
                    floatBuffer.rewind();
                    floatBuffer.get(fftBufferI, fftLength-slideLen, slideLen);
                    // Copy the input buffer into the output buffer
                    System.arraycopy(fftBufferI, 0, fftBufferO, 0, fftLength);
                    // Apply the window function to the buffer
                    for (int i=0; i<fftLength; i++)
                        fftBufferO[i] *= window[i];
                    // Perform the fft
                    fft.realForward(fftBufferO);
                    // Create the array that will hold the amplitutes of the fft
                    // results for this frame
                    float[] fftResults = new float[fftBinCount];
                    // Convert the complex fft results into amplitudes
                    for (int i=0; i<fftBinCount; i++) {
                        float re = fftBufferO[2*i];
                        float im = fftBufferO[2*i+1];
                        float mag = (float)Math.sqrt(re*re + im*im);
                        fftResults[i] = mag;
                        // Keep track of the maximum value for the bin and the
                        // maximum value overall
                        if (data.fftBinMax[i] < mag) {
                            if (data.fftMax < mag)
                                data.fftMax = mag;
                            data.fftBinMax[i] = mag;
                        }
                    }
                    // Store the results
                    data.fftData.add(fftResults);
                    // Increment the frame index
                    data.frameCount++;
                    // If the position of the end of the stream is known and the
                    // center of the current frame is at or beyond the end of
                    // stream then, we're done!
                    if ((eofPos >= 0) && (nextStreamPos - fftLength/2 >= eofPos)) {
                        stateLock.lock();
                        try {
                            state = COMPLETED;
                        } finally {
                            stateLock.unlock();
                        }
                    } 
                    // Otherwise...
                    else {
                        // Update the stream positions for the next frame
                        currStreamPos = nextStreamPos;
                        nextStreamPos = (long)(fftLength*(data.frameCount*(1-fftOverlap)+0.5));
                        // Calcualte the number of samples that will need to be
                        // read from the stream for the next frame
                        slideLen = (int)(nextStreamPos-currStreamPos);
                        // Slide the fft input buffer
                        System.arraycopy(fftBufferI, slideLen, fftBufferI, 0, fftLength-slideLen);
                    }
                }
                
            } catch (Exception ex) {
                // If there was an exception, set the state to cancelled
                stateLock.lock();
                try {
                    state = CANCELLED;
                } finally {
                    stateLock.unlock();
                }   
                // And if there is an exception handler, pass it the exception
                exceptionHandlerLock.lock();
                try {
                    if (exceptionHandler != null)
                        exceptionHandler.uncaughtException(workerThread, ex);
                } finally {
                    exceptionHandlerLock.unlock();
                }
            } finally {
                // Send the terminated singal so that any threads blocke in an
                // awaitTermination method can resume
                stateLock.lock();
                try {
                    termination.signalAll();
                } finally {
                    stateLock.unlock();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("hi");
        File file = new File("E:\\Music\\Nero\\[2011] Welcome Reality\\Nero - Welcome Reality - 07 - Innocence.flac");
//        File file = new File("E:\\Music\\Essential Mix\\Essential Mix (2011-04-16) Alex Metric.mp3");
        AudioDataTask task = new AudioDataTask(file, 44100, 2048, 0);
        task.setExceptionHandler(new UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread thread, Throwable thrown) {
                System.err.println(thrown);
            }
        });
        task.start();
        task.awaitTermination();
        AudioData data = task.getData();
        System.out.println("done");
        System.out.println(data.getFrameCount());
        System.out.println((data.getFrameCount()*2048L)/44100L);
    }
}
